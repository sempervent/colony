# Developer Docs: Corruption & Faults

The corruption and fault system is a core mechanic that adds unpredictability and challenge to the Colony Simulator. This document explains how corruption spreads, how faults occur, and how to implement robust fault handling.

## Overview

The corruption and fault system simulates the inherent instability and entropy in complex systems. As corruption builds up, the likelihood of faults increases, creating cascading failures that players must manage.

### Key Concepts

- **Corruption Field**: A global environmental factor that increases fault probability
- **Soft Faults**: Temporary errors that cause job retries
- **Sticky Faults**: Persistent errors that require worker intervention
- **Fault Propagation**: How faults spread through the system
- **Recovery Mechanisms**: How the system recovers from faults

## Corruption System

### Corruption Field

The corruption field represents systemic instability:

```rust
pub struct CorruptionField {
    pub level: f32,              // Current corruption level (0.0-1.0)
    pub rate: f32,               // Corruption generation rate
    pub decay_rate: f32,         // Natural decay rate
    pub sources: Vec<CorruptionSource>,
    pub mitigation: Vec<CorruptionMitigation>,
    pub threshold: f32,          // Critical threshold
}

pub enum CorruptionSource {
    HighUtilization,             // High system utilization
    ResourceDeficit,             // Resource shortages
    FaultCascade,                // Cascading failures
    BlackSwanEvent,              // Black Swan events
    Environmental,               // Environmental factors
    Aging,                       // System aging
}
```

### Corruption Generation

Corruption is generated by various factors:

```rust
pub struct CorruptionGenerator {
    pub base_rate: f32,          // Base corruption rate
    pub utilization_factor: f32, // Utilization multiplier
    pub resource_factor: f32,    // Resource deficit multiplier
    pub fault_factor: f32,       // Fault cascade multiplier
    pub environmental_factor: f32, // Environmental multiplier
    pub aging_factor: f32,       // System aging multiplier
}

impl CorruptionGenerator {
    pub fn calculate_corruption(&self, context: &SimulationContext) -> f32 {
        let utilization = context.get_utilization();
        let resource_deficit = context.get_resource_deficit();
        let fault_count = context.get_recent_fault_count();
        let age = context.get_system_age();
        
        self.base_rate
            + (utilization * self.utilization_factor)
            + (resource_deficit * self.resource_factor)
            + (fault_count * self.fault_factor)
            + (age * self.aging_factor)
    }
}
```

### Corruption Mitigation

Corruption can be mitigated through various means:

```rust
pub enum CorruptionMitigation {
    Research,                    // Research-based mitigation
    ResourceInvestment,          // Investing in resources
    SystemMaintenance,           // Regular maintenance
    FaultPrevention,             // Preventing faults
    EnvironmentalControl,        // Controlling environment
    Redundancy,                  // System redundancy
}

pub struct MitigationEffect {
    pub mitigation_type: CorruptionMitigation,
    pub effectiveness: f32,      // Mitigation effectiveness
    pub cost: ResourceCost,      // Cost of mitigation
    pub duration: u64,           // Duration of effect
}
```

## Fault System

### Fault Types

The simulation supports different types of faults:

```rust
pub enum FaultType {
    Soft,                        // Temporary, recoverable
    Sticky,                      // Persistent, requires intervention
    Cascading,                   // Spreads to other components
    Environmental,               // Caused by environment
    Hardware,                    // Hardware failure
    Software,                    // Software error
    Network,                     // Network issues
    Resource,                    // Resource exhaustion
}

pub struct Fault {
    pub id: FaultId,
    pub fault_type: FaultType,
    pub severity: FaultSeverity,
    pub source: FaultSource,
    pub affected_components: Vec<ComponentId>,
    pub timestamp: u64,
    pub duration: Option<u64>,   // None for persistent faults
    pub recovery_strategy: RecoveryStrategy,
}
```

### Fault Severity

```rust
pub enum FaultSeverity {
    Minor,                       // Low impact, easy recovery
    Moderate,                    // Medium impact, moderate recovery
    Major,                       // High impact, difficult recovery
    Critical,                    // System-threatening, complex recovery
    Catastrophic,                // System failure, emergency recovery
}
```

### Fault Sources

```rust
pub enum FaultSource {
    Corruption,                  // Caused by corruption
    ResourceExhaustion,          // Resource depletion
    ThermalStress,               // Overheating
    Electrical,                  // Power issues
    Mechanical,                  // Mechanical failure
    Software,                    // Software bugs
    Network,                     // Network problems
    Human,                       // Human error
    External,                    // External factors
}
```

## Fault Generation

### Probability Calculation

Fault probability is calculated based on multiple factors:

```rust
pub struct FaultProbability {
    pub base_probability: f32,   // Base fault probability
    pub corruption_factor: f32,  // Corruption influence
    pub utilization_factor: f32, // Utilization influence
    pub resource_factor: f32,    // Resource influence
    pub thermal_factor: f32,     // Thermal influence
    pub age_factor: f32,         // System age influence
    pub random_factor: f32,      // Random component
}

impl FaultProbability {
    pub fn calculate(&self, context: &SimulationContext) -> f32 {
        let corruption = context.get_corruption_level();
        let utilization = context.get_utilization();
        let resource_deficit = context.get_resource_deficit();
        let temperature = context.get_temperature();
        let age = context.get_system_age();
        
        let probability = self.base_probability
            + (corruption * self.corruption_factor)
            + (utilization * self.utilization_factor)
            + (resource_deficit * self.resource_factor)
            + (temperature * self.thermal_factor)
            + (age * self.age_factor)
            + (thread_rng().gen::<f32>() * self.random_factor);
        
        probability.min(1.0).max(0.0)
    }
}
```

### Fault Triggers

Faults can be triggered by various conditions:

```rust
pub enum FaultTrigger {
    CorruptionThreshold,         // Corruption exceeds threshold
    ResourceExhaustion,          // Resource depleted
    ThermalLimit,                // Temperature too high
    UtilizationLimit,            // Utilization too high
    TimeBased,                   // Time-based triggers
    Random,                      // Random triggers
    Cascade,                     // Cascading from other faults
    External,                    // External triggers
}
```

## Fault Handling

### Soft Faults

Soft faults are temporary and can be recovered automatically:

```rust
pub struct SoftFault {
    pub id: FaultId,
    pub component_id: ComponentId,
    pub error_type: ErrorType,
    pub retry_count: u32,
    pub max_retries: u32,
    pub retry_delay: u64,
    pub recovery_probability: f32,
}

impl SoftFault {
    pub fn handle(&mut self, context: &mut SimulationContext) -> FaultResult {
        if self.retry_count < self.max_retries {
            self.retry_count += 1;
            
            // Attempt recovery
            if thread_rng().gen::<f32>() < self.recovery_probability {
                FaultResult::Recovered
            } else {
                FaultResult::Retry
            }
        } else {
            FaultResult::Escalated
        }
    }
}
```

### Sticky Faults

Sticky faults require manual intervention:

```rust
pub struct StickyFault {
    pub id: FaultId,
    pub component_id: ComponentId,
    pub fault_type: StickyFaultType,
    pub severity: FaultSeverity,
    pub recovery_actions: Vec<RecoveryAction>,
    pub auto_recovery_time: Option<u64>,
    pub manual_recovery_required: bool,
}

pub enum StickyFaultType {
    WorkerStuck,                 // Worker becomes unresponsive
    ResourceLocked,              // Resource becomes locked
    SystemHang,                  // System hangs
    DataCorruption,              // Data corruption
    HardwareFailure,             // Hardware failure
    SoftwareCrash,               // Software crash
}
```

### Recovery Actions

```rust
pub enum RecoveryAction {
    Reset,                       // Reset component
    Restart,                     // Restart component
    Reallocate,                  // Reallocate resources
    Repair,                      // Repair component
    Replace,                     // Replace component
    Bypass,                      // Bypass component
    Manual,                      // Manual intervention
}
```

## Fault Propagation

### Cascade Effects

Faults can spread through the system:

```rust
pub struct FaultCascade {
    pub primary_fault: FaultId,
    pub cascade_chain: Vec<FaultId>,
    pub propagation_rate: f32,
    pub affected_systems: Vec<SystemId>,
    pub cascade_severity: FaultSeverity,
}

pub struct CascadeRule {
    pub source_fault_type: FaultType,
    pub target_component_types: Vec<ComponentType>,
    pub propagation_probability: f32,
    pub delay: u64,
    pub severity_modifier: f32,
}
```

### Propagation Logic

```rust
impl FaultCascade {
    pub fn propagate(&mut self, context: &mut SimulationContext) {
        for rule in &context.cascade_rules {
            if self.matches_rule(rule) {
                let probability = rule.propagation_probability
                    * context.get_corruption_level()
                    * context.get_system_stress();
                
                if thread_rng().gen::<f32>() < probability {
                    self.create_cascade_fault(rule, context);
                }
            }
        }
    }
}
```

## Retry Policies

### Retry Strategies

Different retry strategies for handling faults:

```rust
pub enum RetryStrategy {
    Immediate,                   // Retry immediately
    ExponentialBackoff,          // Exponential backoff
    LinearBackoff,               // Linear backoff
    FixedDelay,                  // Fixed delay
    Adaptive,                    // Adaptive based on conditions
    CircuitBreaker,              // Circuit breaker pattern
}

pub struct RetryPolicy {
    pub strategy: RetryStrategy,
    pub max_retries: u32,
    pub base_delay: u64,
    pub max_delay: u64,
    pub backoff_factor: f32,
    pub circuit_breaker_threshold: u32,
}
```

### Implementation

```rust
impl RetryPolicy {
    pub fn calculate_delay(&self, retry_count: u32) -> u64 {
        match self.strategy {
            RetryStrategy::Immediate => 0,
            RetryStrategy::ExponentialBackoff => {
                let delay = (self.base_delay as f32 * self.backoff_factor.powi(retry_count as i32)) as u64;
                delay.min(self.max_delay)
            },
            RetryStrategy::LinearBackoff => {
                (self.base_delay * retry_count).min(self.max_delay)
            },
            RetryStrategy::FixedDelay => self.base_delay,
            RetryStrategy::Adaptive => {
                // Adaptive based on system conditions
                self.calculate_adaptive_delay(retry_count)
            },
            RetryStrategy::CircuitBreaker => {
                if retry_count >= self.circuit_breaker_threshold {
                    self.max_delay
                } else {
                    self.calculate_delay(retry_count)
                }
            },
        }
    }
}
```

## Monitoring and Metrics

### Fault Metrics

```rust
pub struct FaultMetrics {
    pub total_faults: u64,
    pub soft_faults: u64,
    pub sticky_faults: u64,
    pub cascading_faults: u64,
    pub fault_rate: f32,         // Faults per tick
    pub recovery_rate: f32,      // Recovery rate
    pub mean_time_to_recovery: f32,
    pub fault_severity_distribution: HashMap<FaultSeverity, u64>,
    pub fault_source_distribution: HashMap<FaultSource, u64>,
}
```

### Corruption Metrics

```rust
pub struct CorruptionMetrics {
    pub current_level: f32,
    pub peak_level: f32,
    pub average_level: f32,
    pub generation_rate: f32,
    pub decay_rate: f32,
    pub mitigation_effectiveness: f32,
    pub threshold_breaches: u64,
    pub time_above_threshold: u64,
}
```

## Configuration

### Fault Configuration

```toml
# In game configuration
[faults]
base_probability = 0.001         # Base fault probability per tick
corruption_factor = 0.5          # Corruption influence factor
utilization_factor = 0.3         # Utilization influence factor
resource_factor = 0.4            # Resource influence factor
thermal_factor = 0.2             # Thermal influence factor
age_factor = 0.1                 # Age influence factor
random_factor = 0.1              # Random component factor

[faults.soft_faults]
max_retries = 3
retry_delay = 10
recovery_probability = 0.8

[faults.sticky_faults]
auto_recovery_time = 1000
manual_recovery_required = true
recovery_actions = ["reset", "restart", "reallocate"]
```

### Corruption Configuration

```toml
[corruption]
base_rate = 0.0001               # Base corruption rate per tick
utilization_factor = 0.2         # Utilization multiplier
resource_factor = 0.3            # Resource deficit multiplier
fault_factor = 0.5               # Fault cascade multiplier
environmental_factor = 0.1       # Environmental multiplier
aging_factor = 0.05              # System aging multiplier
decay_rate = 0.00005             # Natural decay rate
threshold = 0.8                  # Critical threshold
```

## Testing

### Unit Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_corruption_generation() {
        let generator = CorruptionGenerator::new();
        let context = create_test_context();
        
        let corruption = generator.calculate_corruption(&context);
        assert!(corruption >= 0.0 && corruption <= 1.0);
    }
    
    #[test]
    fn test_fault_probability() {
        let probability = FaultProbability::new();
        let context = create_test_context();
        
        let fault_prob = probability.calculate(&context);
        assert!(fault_prob >= 0.0 && fault_prob <= 1.0);
    }
    
    #[test]
    fn test_soft_fault_recovery() {
        let mut fault = SoftFault::new();
        let mut context = create_test_context();
        
        let result = fault.handle(&mut context);
        assert!(matches!(result, FaultResult::Recovered | FaultResult::Retry));
    }
}
```

### Integration Tests

```rust
#[cfg(test)]
mod integration_tests {
    use super::*;
    
    #[test]
    fn test_fault_cascade() {
        let mut simulation = create_test_simulation();
        let primary_fault = create_test_fault();
        
        simulation.trigger_fault(primary_fault);
        
        // Run simulation for several ticks
        for _ in 0..100 {
            simulation.tick();
        }
        
        let cascade_count = simulation.get_cascade_fault_count();
        assert!(cascade_count > 0);
    }
    
    #[test]
    fn test_corruption_mitigation() {
        let mut simulation = create_test_simulation();
        let mitigation = create_test_mitigation();
        
        simulation.apply_mitigation(mitigation);
        
        // Run simulation for several ticks
        for _ in 0..100 {
            simulation.tick();
        }
        
        let corruption_level = simulation.get_corruption_level();
        assert!(corruption_level < 0.5);
    }
}
```

## Best Practices

### Design Guidelines

1. **Fault Tolerance**: Design systems to handle faults gracefully
2. **Recovery Strategies**: Implement multiple recovery strategies
3. **Monitoring**: Monitor fault patterns and trends
4. **Prevention**: Implement fault prevention mechanisms
5. **Documentation**: Document fault handling procedures

### Performance Considerations

1. **Efficient Detection**: Optimize fault detection algorithms
2. **Quick Recovery**: Minimize recovery time
3. **Resource Management**: Manage resources during faults
4. **Cascade Prevention**: Prevent fault cascades
5. **Monitoring Overhead**: Minimize monitoring overhead

## Troubleshooting

### Common Issues

1. **Fault Cascades**: Uncontrolled fault propagation
2. **Recovery Failures**: Faults that don't recover
3. **Performance Impact**: Faults affecting performance
4. **Resource Exhaustion**: Faults consuming too many resources
5. **Monitoring Gaps**: Missing fault detection

### Debug Tools

- **Fault Tracker**: Track fault occurrence and recovery
- **Corruption Monitor**: Monitor corruption levels and trends
- **Cascade Analyzer**: Analyze fault cascade patterns
- **Recovery Tester**: Test recovery mechanisms
- **Performance Profiler**: Profile fault handling performance

---

**The corruption and fault system adds realistic complexity to the Colony Simulator. Understanding and managing these systems is key to building resilient simulations.** ðŸ­âš¡
